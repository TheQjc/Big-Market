# 防超卖与库存回滚防护策略

在 `ActivityRepository` 的库存扣减逻辑中，实现了一种非常严谨的**双重保障机制**。除了使用 Redis 的原子递减来应对高并发流量外，还引入了**“库存令牌（Token）独占”**机制，以防止因人为修改缓存或系统错误导致同一个“库存名额”被重复发放。

## 1. 代码定位

👉 **点击跳转到核心代码**: [ActivityRepository.java - subtractionActivitySkuStock](/cn/bugstack/infrastructure/persistent/repository/ActivityRepository.java#L182)

```java
@Override
public boolean subtractionActivitySkuStock(Long sku, String cacheKey, Date endDateTime) {
    long surplus = redisService.decr(cacheKey);
    // ... Sku归零发送MQ消息 ...

    // 1. 按照cacheKey decr 后的值，如 99、98、97 和 key 组成为库存锁的key进行使用。
    // 2. 加锁为了兜底，如果后续有恢复库存，手动处理等...
    String lockKey = cacheKey + Constants.UNDERLINE + surplus;
    // ...
    Boolean lock = redisService.setNx(lockKey, expireMillis, TimeUnit.MILLISECONDS);
    // ...
    return lock;
}
```

## 2. 核心逻辑深度解析

假设当前活动商品 SKU=1001，Redis 中记录的库存 (`cacheKey`) 是 100。

### 第一重保障：原子递减 (Atomic Decr)
*   **代码**: `long surplus = redisService.decr(cacheKey);`
*   **作用**: 利用 Redis 单线程特性，保证多个请求并发扣减时，不会出现计算错误（如两个请求同时读到 100，都减 1 变成 99）。
*   **结果**: 当用户 A 扣减库存后，`surplus` (剩余库存) = 99。这就好比用户 A 拿到了“第 99 号”商品的购买资格。

### 第二重保障：令牌独占 (Token Occupation)
*   **代码**: `Boolean lock = redisService.setNx(lockKey, ...);`
*   **目的**: 防止库存被意外回滚导致的超卖（**核心兜底**）。
*   **场景推演**:
    1.  **正常流程**: 库存 100 -> 99。用户 A 拿走第 99 号库存。系统生成唯一锁 `key_99` 并加锁成功。
    2.  **异常情况**: 运营人员误操作将 Redis 库存数值重置回了 100。
    3.  **攻击/并发**: 用户 B 进来抽奖，库存再次从 100 -> 99。用户 B 也拿到了“第 99 号”资格。
    4.  **拦截机制**: 用户 B 尝试去抢占 `key_99` 锁。因为用户 A 已经锁住了 `key_99`，**用户 B 的 `setNx` 操作会失败** (`lock` 返回 false)。
*   **结论**: 这确保了每一个具体的“库存名额”（第99个、第98个...）在整个活动周期内**只能被消耗一次**，即使总库存数被错误回滚，在这个层面上也能拦截住，实现了**库存操作的幂等性**。

### 第三点：生命周期管理
*   **代码**: `long expireMillis = endDateTime.getTime() - ... + TimeUnit.DAYS.toMillis(1);`
*   **策略**: 只要活动还在进行，这个坑位就必须一直被锁住。过期时间设置为 `活动结束时间 + 1天`，既保证了活动期间的安全性，又避免了永久占用 Redis 内存。
